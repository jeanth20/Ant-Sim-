"""
Ant Simulation Debug Log Analyzer

This script analyzes the debug logs generated by the ant simulation
to help identify performance issues and bugs.
"""

import os
import json
import sys
import argparse
from datetime import datetime
import matplotlib.pyplot as plt
import numpy as np

def load_log_file(filename):
    """Load a debug log file."""
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading log file {filename}: {e}")
        return None

def list_log_files():
    """List all available log files."""
    if not os.path.exists('logs'):
        print("No logs directory found.")
        return []
    
    log_files = [f for f in os.listdir('logs') if f.endswith('.json')]
    log_files.sort(reverse=True)  # Most recent first
    return log_files

def print_log_summary(log_data):
    """Print a summary of the log data."""
    timestamp = datetime.fromtimestamp(log_data['timestamp'] / 1000)
    
    print(f"\n=== Log Summary for {timestamp} ===")
    
    # Performance metrics
    fps_values = [entry['value'] for entry in log_data['metrics']['fps']] if 'fps' in log_data['metrics'] else []
    frame_time_values = [entry['value'] for entry in log_data['metrics']['frameTime']] if 'frameTime' in log_data['metrics'] else []
    
    if fps_values:
        avg_fps = sum(fps_values) / len(fps_values)
        min_fps = min(fps_values)
        max_fps = max(fps_values)
        print(f"\nPerformance:")
        print(f"  FPS: avg={avg_fps:.1f}, min={min_fps:.1f}, max={max_fps:.1f}")
    
    if frame_time_values:
        avg_frame_time = sum(frame_time_values) / len(frame_time_values)
        min_frame_time = min(frame_time_values)
        max_frame_time = max(frame_time_values)
        print(f"  Frame Time: avg={avg_frame_time:.2f}ms, min={min_frame_time:.2f}ms, max={max_frame_time:.2f}ms")
    
    # Object counts
    print("\nObject Counts:")
    for obj_type in ['antCount', 'foodCount', 'obstacleCount', 'predatorCount']:
        if obj_type in log_data['metrics']:
            if isinstance(log_data['metrics'][obj_type], list):
                if log_data['metrics'][obj_type]:
                    count = log_data['metrics'][obj_type][-1]['value']
                    print(f"  {obj_type.replace('Count', '')}: {count}")
            else:
                print(f"  {obj_type.replace('Count', '')}: {log_data['metrics'][obj_type]}")
    
    # Memory usage
    if 'memoryUsage' in log_data['metrics']:
        if isinstance(log_data['metrics']['memoryUsage'], list):
            if log_data['metrics']['memoryUsage']:
                memory = log_data['metrics']['memoryUsage'][-1]['value']
                print(f"\nMemory Usage: {memory} MB")
        else:
            print(f"\nMemory Usage: {log_data['metrics']['memoryUsage']} MB")
    
    # Function timings
    print("\nFunction Timings (Top 5 by avg time):")
    timings = []
    for func_name, timing in log_data['functionTimings'].items():
        if timing['calls'] > 0:
            avg_time = timing['totalTime'] / timing['calls']
            timings.append((func_name, avg_time, timing['maxTime'], timing['calls']))
    
    # Sort by average time (descending)
    timings.sort(key=lambda x: x[1], reverse=True)
    
    # Print top 5
    for i, (func_name, avg_time, max_time, calls) in enumerate(timings[:5]):
        print(f"  {i+1}. {func_name}: avg={avg_time:.2f}ms, max={max_time:.2f}ms, calls={calls}")
    
    # Long frames
    if log_data['longFrames']:
        print(f"\nLong Frames: {len(log_data['longFrames'])}")
        print("  Top 3 longest frames:")
        sorted_frames = sorted(log_data['longFrames'], key=lambda x: x['duration'], reverse=True)
        for i, frame in enumerate(sorted_frames[:3]):
            frame_time = datetime.fromtimestamp(frame['time'] / 1000).strftime('%H:%M:%S')
            print(f"  {i+1}. {frame_time}: {frame['duration']:.2f}ms with {frame['antCount']} ants")
    
    # Errors and warnings
    if log_data['errors']:
        print(f"\nErrors: {len(log_data['errors'])}")
        for i, error in enumerate(log_data['errors'][:3]):
            error_time = datetime.fromtimestamp(error['time'] / 1000).strftime('%H:%M:%S')
            print(f"  {i+1}. {error_time}: {error['message']}")
    
    if log_data['warnings']:
        print(f"\nWarnings: {len(log_data['warnings'])}")
        for i, warning in enumerate(log_data['warnings'][:3]):
            warning_time = datetime.fromtimestamp(warning['time'] / 1000).strftime('%H:%M:%S')
            print(f"  {i+1}. {warning_time}: {warning['message']}")

def plot_performance_graphs(log_data):
    """Plot performance graphs from the log data."""
    # Create a figure with subplots
    fig, axs = plt.subplots(2, 1, figsize=(10, 8))
    
    # Plot FPS
    if 'fps' in log_data['metrics'] and log_data['metrics']['fps']:
        fps_values = [entry['value'] for entry in log_data['metrics']['fps']]
        axs[0].plot(fps_values)
        axs[0].set_title('FPS over time')
        axs[0].set_ylabel('FPS')
        axs[0].grid(True)
        
        # Add a horizontal line at 30 FPS (common target)
        axs[0].axhline(y=30, color='r', linestyle='--', alpha=0.5)
        axs[0].text(0, 30, '30 FPS', color='r', va='bottom')
    
    # Plot Frame Time
    if 'frameTime' in log_data['metrics'] and log_data['metrics']['frameTime']:
        frame_time_values = [entry['value'] for entry in log_data['metrics']['frameTime']]
        axs[1].plot(frame_time_values)
        axs[1].set_title('Frame Time over time')
        axs[1].set_ylabel('Time (ms)')
        axs[1].set_xlabel('Frame')
        axs[1].grid(True)
        
        # Add a horizontal line at 33.3ms (30 FPS)
        axs[1].axhline(y=33.3, color='r', linestyle='--', alpha=0.5)
        axs[1].text(0, 33.3, '33.3ms (30 FPS)', color='r', va='bottom')
    
    plt.tight_layout()
    
    # Create a timestamp for the filename
    timestamp = datetime.fromtimestamp(log_data['timestamp'] / 1000).strftime('%Y%m%d_%H%M%S')
    filename = f'performance_{timestamp}.png'
    
    # Save the figure
    plt.savefig(filename)
    print(f"\nPerformance graph saved as {filename}")
    
    # Show the figure
    plt.show()

def analyze_function_timings(log_data):
    """Analyze function timings to identify bottlenecks."""
    print("\n=== Function Timing Analysis ===")
    
    # Calculate total time spent in each function
    timings = []
    for func_name, timing in log_data['functionTimings'].items():
        if timing['calls'] > 0:
            avg_time = timing['totalTime'] / timing['calls']
            total_time = timing['totalTime']
            timings.append((func_name, avg_time, total_time, timing['maxTime'], timing['calls']))
    
    # Sort by total time (descending)
    timings.sort(key=lambda x: x[2], reverse=True)
    
    # Calculate total time across all functions
    total_all_functions = sum(t[2] for t in timings)
    
    print("Top 10 functions by total time:")
    for i, (func_name, avg_time, total_time, max_time, calls) in enumerate(timings[:10]):
        percentage = (total_time / total_all_functions) * 100 if total_all_functions > 0 else 0
        print(f"  {i+1}. {func_name}:")
        print(f"     Total: {total_time:.2f}ms ({percentage:.1f}% of all function time)")
        print(f"     Avg: {avg_time:.2f}ms, Max: {max_time:.2f}ms, Calls: {calls}")
    
    # Plot function timings as a pie chart
    if timings:
        plt.figure(figsize=(10, 8))
        
        # Get top 5 functions, group the rest as "Other"
        top_funcs = timings[:5]
        other_time = sum(t[2] for t in timings[5:])
        
        labels = [t[0] for t in top_funcs]
        if other_time > 0:
            labels.append('Other')
        
        sizes = [t[2] for t in top_funcs]
        if other_time > 0:
            sizes.append(other_time)
        
        plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
        plt.axis('equal')
        plt.title('Function Time Distribution')
        
        # Save the figure
        timestamp = datetime.fromtimestamp(log_data['timestamp'] / 1000).strftime('%Y%m%d_%H%M%S')
        filename = f'function_timings_{timestamp}.png'
        plt.savefig(filename)
        print(f"\nFunction timing graph saved as {filename}")
        
        plt.show()

def analyze_long_frames(log_data):
    """Analyze long frames to identify patterns."""
    if not log_data['longFrames']:
        print("\nNo long frames recorded.")
        return
    
    print("\n=== Long Frame Analysis ===")
    print(f"Total long frames: {len(log_data['longFrames'])}")
    
    # Calculate average values
    avg_duration = sum(frame['duration'] for frame in log_data['longFrames']) / len(log_data['longFrames'])
    avg_ants = sum(frame['antCount'] for frame in log_data['longFrames']) / len(log_data['longFrames'])
    avg_food = sum(frame['foodCount'] for frame in log_data['longFrames']) / len(log_data['longFrames'])
    avg_obstacles = sum(frame['obstacleCount'] for frame in log_data['longFrames']) / len(log_data['longFrames'])
    
    print(f"Average duration: {avg_duration:.2f}ms")
    print(f"Average ant count: {avg_ants:.1f}")
    print(f"Average food count: {avg_food:.1f}")
    print(f"Average obstacle count: {avg_obstacles:.1f}")
    
    # Check for correlation between frame duration and object counts
    durations = [frame['duration'] for frame in log_data['longFrames']]
    ant_counts = [frame['antCount'] for frame in log_data['longFrames']]
    food_counts = [frame['foodCount'] for frame in log_data['longFrames']]
    obstacle_counts = [frame['obstacleCount'] for frame in log_data['longFrames']]
    
    # Calculate correlation coefficients
    if len(durations) > 1:
        ant_corr = np.corrcoef(durations, ant_counts)[0, 1]
        food_corr = np.corrcoef(durations, food_counts)[0, 1]
        obstacle_corr = np.corrcoef(durations, obstacle_counts)[0, 1]
        
        print("\nCorrelation with frame duration:")
        print(f"  Ant count: {ant_corr:.2f}")
        print(f"  Food count: {food_corr:.2f}")
        print(f"  Obstacle count: {obstacle_corr:.2f}")
        
        # Identify the strongest correlation
        correlations = [
            ("Ant count", ant_corr),
            ("Food count", food_corr),
            ("Obstacle count", obstacle_corr)
        ]
        
        strongest = max(correlations, key=lambda x: abs(x[1]))
        
        if abs(strongest[1]) > 0.5:
            print(f"\nStrongest correlation: {strongest[0]} ({strongest[1]:.2f})")
            if strongest[1] > 0:
                print(f"This suggests that increasing {strongest[0].lower()} leads to longer frame times.")
            else:
                print(f"This suggests that increasing {strongest[0].lower()} leads to shorter frame times (unusual).")
        else:
            print("\nNo strong correlations found. Frame duration may be affected by other factors.")
    
    # Plot scatter plots
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    
    axs[0].scatter(ant_counts, durations)
    axs[0].set_title('Frame Duration vs Ant Count')
    axs[0].set_xlabel('Ant Count')
    axs[0].set_ylabel('Duration (ms)')
    axs[0].grid(True)
    
    axs[1].scatter(food_counts, durations)
    axs[1].set_title('Frame Duration vs Food Count')
    axs[1].set_xlabel('Food Count')
    axs[1].set_ylabel('Duration (ms)')
    axs[1].grid(True)
    
    axs[2].scatter(obstacle_counts, durations)
    axs[2].set_title('Frame Duration vs Obstacle Count')
    axs[2].set_xlabel('Obstacle Count')
    axs[2].set_ylabel('Duration (ms)')
    axs[2].grid(True)
    
    plt.tight_layout()
    
    # Save the figure
    timestamp = datetime.fromtimestamp(log_data['timestamp'] / 1000).strftime('%Y%m%d_%H%M%S')
    filename = f'long_frames_{timestamp}.png'
    plt.savefig(filename)
    print(f"\nLong frames analysis graph saved as {filename}")
    
    plt.show()

def main():
    parser = argparse.ArgumentParser(description='Analyze Ant Simulation debug logs')
    parser.add_argument('--list', action='store_true', help='List available log files')
    parser.add_argument('--file', type=str, help='Analyze a specific log file')
    parser.add_argument('--latest', action='store_true', help='Analyze the latest log file')
    parser.add_argument('--summary', action='store_true', help='Print a summary of the log')
    parser.add_argument('--performance', action='store_true', help='Plot performance graphs')
    parser.add_argument('--functions', action='store_true', help='Analyze function timings')
    parser.add_argument('--long-frames', action='store_true', help='Analyze long frames')
    parser.add_argument('--all', action='store_true', help='Run all analyses')
    
    args = parser.parse_args()
    
    # If no arguments provided, show help
    if len(sys.argv) == 1:
        parser.print_help()
        return
    
    # List available log files
    if args.list:
        log_files = list_log_files()
        if log_files:
            print("Available log files:")
            for i, file in enumerate(log_files):
                print(f"  {i+1}. {file}")
        return
    
    # Determine which log file to analyze
    log_file = None
    if args.file:
        log_file = args.file
        if not os.path.exists(log_file):
            log_file = os.path.join('logs', log_file)
            if not os.path.exists(log_file):
                print(f"Error: Log file {args.file} not found.")
                return
    elif args.latest:
        log_files = list_log_files()
        if log_files:
            log_file = os.path.join('logs', log_files[0])
        else:
            print("No log files found.")
            return
    
    if not log_file:
        print("No log file specified. Use --file or --latest.")
        return
    
    # Load the log file
    log_data = load_log_file(log_file)
    if not log_data:
        return
    
    # Run the requested analyses
    if args.summary or args.all:
        print_log_summary(log_data)
    
    if args.performance or args.all:
        plot_performance_graphs(log_data)
    
    if args.functions or args.all:
        analyze_function_timings(log_data)
    
    if args.long_frames or args.all:
        analyze_long_frames(log_data)

if __name__ == '__main__':
    main()
